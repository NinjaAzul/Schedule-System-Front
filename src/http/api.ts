/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Scheduler API
 * Scheduler API
 * OpenAPI spec version: 1.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from '../services/axios';
export interface CreateUserDto {
  /** The name of the user */
  name: string;
  /** The email of the user */
  email: string;
  /** The password of the user */
  password: string;
  /** The role id of the user */
  roleId: number;
}

export interface CommonResponseWithIdDto {
  /** The id of the entity */
  id: number;
  /** The message of the response */
  message: string;
}

export interface CommonErrorResponseDto {
  /** The status code of the error */
  statusCode: number;
  /** The message of the error */
  message: string;
  /** The error of the error */
  error: string;
}

/**
 * The error associated with the property
 */
export type ValidationErrorError = {[key: string]: string};

export interface ValidationError {
  /** The property that contains the error */
  property: string;
  /** The error associated with the property */
  error: ValidationErrorError;
  /** Child validation errors */
  children: string[];
}

export interface MessageError {
  /** The info of the error */
  info: string;
  /** The errors of the error */
  errors: ValidationError[];
}

export interface ValidationErrorResponseDto {
  /** The HTTP status code */
  statusCode: number;
  /** The error message */
  message: MessageError;
  /** The error type */
  error: string;
}

export interface RoleDto {
  /** The role ID */
  id: number;
  /** The role name */
  name: string;
}

export interface UserDto {
  /** The user ID */
  id: number;
  /** The user name */
  name: string;
  /** The user email */
  email: string;
  /** The user active */
  active: boolean;
  /** The user role */
  role: RoleDto;
  /** The user created at */
  createdAt: string;
  /** The user updated at */
  updatedAt: string;
}

export interface PaginationResponseDto {
  /** The total number of items */
  skip: number;
  /** The total number of pages */
  page: number;
  /** The total number of items per page */
  take: number;
  /** The total number of pages */
  totalPages: number;
}

export interface FindAllUsersResponseDto {
  /** The users */
  users: UserDto[];
  /** The pagination */
  pagination?: PaginationResponseDto;
}

export interface FindUserResponseDto {
  /** The user ID */
  id: number;
  /** The user name */
  name: string;
  /** The user email */
  email: string;
  /** The user active */
  active: boolean;
  /** The user role */
  role: RoleDto;
  /** The user created at */
  createdAt: string;
  /** The user updated at */
  updatedAt: string;
}

export interface UpdateUserDto {
  /** The name of the user */
  name: string;
  /** The email of the user */
  email: string;
  /** The role id of the user */
  roleId: number;
}

export interface AuthenticateRequestDTO {
  /** The email of the user */
  email: string;
  /** The password of the user */
  password: string;
}

export interface AuthenticateResponseDto {
  /** The user object */
  user: UserDto;
  /** The authentication token */
  token: string;
}

export interface MeResponseDto {
  /** The user object */
  user: UserDto;
  /** The authentication token */
  token: string;
}

export interface CreateServiceDto {
  /** The name of the service */
  name: string;
  /** The duration of the service */
  duration: number;
  /** The price of the service */
  price: number;
  /** The start hour of the service */
  startHour: string;
  /** The end hour of the service */
  endHour: string;
}

export interface CommonResponseDto {
  /** The message of the response */
  message: string;
}

export interface Service {
  /** The name of the service */
  name: string;
  /** The id of the service */
  id: number;
  /** The duration of the service */
  duration: number;
  /** The start time of the service */
  startTime: string;
  /** The end time of the service */
  endTime: string;
  /** The price of the service */
  price: number;
  /** The created at date of the service */
  createdAt: string;
  /** The updated at date of the service */
  updatedAt: string;
}

export interface FindAllServicesResponseDto {
  /** The services */
  services: Service[];
  /** The pagination */
  pagination?: PaginationResponseDto;
}

export interface TimeSlot {
  /** The hours of the time slot */
  hours?: string;
  /** The day of the time slot */
  day?: string;
}

export interface FindAllAvailabilityServiceResponseDto {
  /** The date of the availability */
  date: string;
  /** The available times for the date */
  times: TimeSlot[];
}

export interface CreateAppointmentDto {
  /** The ID of the user */
  userId?: number;
  /** The ID of the service */
  serviceId: number;
  /** The date and time of the appointment */
  scheduledAt: string;
}

export interface ServiceDto {
  /** The ID of the service */
  id: number;
  /** The name of the service */
  name: string;
  /** The price of the service */
  price: number;
}

export interface AppointmentResponseDto {
  /** The ID of the appointment */
  id: number;
  /** The date and time the appointment is scheduled for */
  scheduledAt: string;
  /** The date and time the appointment was created */
  createdAt: string;
  /** The date and time the appointment was last updated */
  updatedAt: string;
  /** The ID of the user associated with the appointment */
  userId: number;
  /** The service associated with the appointment */
  service: ServiceDto;
}

export interface FindAllAppointmentsResponseDto {
  /** List of appointments */
  appointments: AppointmentResponseDto[];
  /** Pagination information */
  pagination: PaginationResponseDto;
}

export type UsersControllerFindAllParams = {
/**
 * The search query
 */
search?: string;
/**
 * The active status of the user
 */
active?: boolean;
/**
 * The role id of the user
 */
roleId?: number;
/**
 * The page number
 */
page?: number;
/**
 * The number of items per page
 */
take?: number;
};

export type ServicesControllerFindAllParams = {
/**
 * The search query
 */
search?: string;
/**
 * The page number
 */
page?: number;
/**
 * The number of items per page
 */
take?: number;
/**
 * The from date
 */
fromDate?: string;
/**
 * The to date
 */
toDate?: string;
/**
 * The service id
 */
serviceId?: number;
};

export type ServicesControllerFindAvailabilityParams = {
/**
 * The page number
 */
page?: number;
/**
 * The number of items per page
 */
take?: number;
/**
 * The from date
 */
fromDate?: string;
/**
 * The to date
 */
toDate?: string;
};

export type AppointmentsControllerFindAllParams = {
/**
 * The search query
 */
search?: string;
/**
 * The page number
 */
page?: number;
/**
 * The number of items per page
 */
take?: number;
/**
 * The from date
 */
fromDate?: string;
/**
 * The to date
 */
toDate?: string;
/**
 * The service id
 */
serviceId?: number;
/**
 * The user id
 */
userId?: number;
};

/**
 * @summary Create a new user
 */
export const usersControllerCreate = (
    createUserDto: CreateUserDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CommonResponseWithIdDto>(
      {url: `http://localhost:3002/users/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      );
    }
  


export const getUsersControllerCreateMutationOptions = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext> => {
    
const mutationKey = ['usersControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerCreate>>, {data: CreateUserDto}> = (props) => {
          const {data} = props ?? {};

          return  usersControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerCreate>>>
    export type UsersControllerCreateMutationBody = CreateUserDto
    export type UsersControllerCreateMutationError = CommonErrorResponseDto | ValidationErrorResponseDto

    /**
 * @summary Create a new user
 */
export const useUsersControllerCreate = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerCreate>>, TError,{data: CreateUserDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerCreate>>,
        TError,
        {data: CreateUserDto},
        TContext
      > => {

      const mutationOptions = getUsersControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all users
 */
export const usersControllerFindAll = (
    params?: UsersControllerFindAllParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FindAllUsersResponseDto>(
      {url: `http://localhost:3002/users/list`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getUsersControllerFindAllQueryKey = (params?: UsersControllerFindAllParams,) => {
    return [`http://localhost:3002/users/list`, ...(params ? [params]: [])] as const;
    }

    
export const getUsersControllerFindAllInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindAll>>>, TError = unknown>(params?: UsersControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindAll>>> = ({ signal }) => usersControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindAll>>>
export type UsersControllerFindAllInfiniteQueryError = unknown


export function useUsersControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindAll>>>, TError = unknown>(
 params: undefined |  UsersControllerFindAllParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindAll>>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindAll>>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all users
 */

export function useUsersControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindAll>>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindAllInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUsersControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindAll>>> = ({ signal }) => usersControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindAll>>>
export type UsersControllerFindAllQueryError = unknown


export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
 params: undefined |  UsersControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all users
 */

export function useUsersControllerFindAll<TData = Awaited<ReturnType<typeof usersControllerFindAll>>, TError = unknown>(
 params?: UsersControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a user by id
 */
export const usersControllerFindOne = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FindUserResponseDto>(
      {url: `http://localhost:3002/users/find/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getUsersControllerFindOneQueryKey = (id: number,) => {
    return [`http://localhost:3002/users/find/${id}`] as const;
    }

    
export const getUsersControllerFindOneInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindOne>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindOne>>> = ({ signal }) => usersControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindOneInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindOne>>>
export type UsersControllerFindOneInfiniteQueryError = unknown


export function useUsersControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindOne>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindOne>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindOne>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a user by id
 */

export function useUsersControllerFindOneInfinite<TData = InfiniteData<Awaited<ReturnType<typeof usersControllerFindOne>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindOneInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUsersControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersControllerFindOne>>> = ({ signal }) => usersControllerFindOne(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof usersControllerFindOne>>>
export type UsersControllerFindOneQueryError = unknown


export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof usersControllerFindOne>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get a user by id
 */

export function useUsersControllerFindOne<TData = Awaited<ReturnType<typeof usersControllerFindOne>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersControllerFindOne>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update a user
 */
export const usersControllerUpdate = (
    id: number,
    updateUserDto: UpdateUserDto,
 ) => {
      
      
      return customInstance<CommonResponseWithIdDto>(
      {url: `http://localhost:3002/users/update/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      );
    }
  


export const getUsersControllerUpdateMutationOptions = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: number;data: UpdateUserDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: number;data: UpdateUserDto}, TContext> => {
    
const mutationKey = ['usersControllerUpdate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerUpdate>>, {id: number;data: UpdateUserDto}> = (props) => {
          const {id,data} = props ?? {};

          return  usersControllerUpdate(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerUpdate>>>
    export type UsersControllerUpdateMutationBody = UpdateUserDto
    export type UsersControllerUpdateMutationError = CommonErrorResponseDto | ValidationErrorResponseDto

    /**
 * @summary Update a user
 */
export const useUsersControllerUpdate = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerUpdate>>, TError,{id: number;data: UpdateUserDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerUpdate>>,
        TError,
        {id: number;data: UpdateUserDto},
        TContext
      > => {

      const mutationOptions = getUsersControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a user
 */
export const usersControllerRemove = (
    id: number,
 ) => {
      
      
      return customInstance<CommonResponseWithIdDto>(
      {url: `http://localhost:3002/users/delete/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getUsersControllerRemoveMutationOptions = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['usersControllerRemove'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersControllerRemove>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  usersControllerRemove(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof usersControllerRemove>>>
    
    export type UsersControllerRemoveMutationError = CommonErrorResponseDto | ValidationErrorResponseDto

    /**
 * @summary Delete a user
 */
export const useUsersControllerRemove = <TError = CommonErrorResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersControllerRemove>>, TError,{id: number}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof usersControllerRemove>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getUsersControllerRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Authenticate a user
 */
export const authControllerAuthenticate = (
    authenticateRequestDTO: AuthenticateRequestDTO,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticateResponseDto>(
      {url: `http://localhost:3002/auth`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: authenticateRequestDTO, signal
    },
      );
    }
  


export const getAuthControllerAuthenticateMutationOptions = <TError = ValidationErrorResponseDto | CommonErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerAuthenticate>>, TError,{data: AuthenticateRequestDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authControllerAuthenticate>>, TError,{data: AuthenticateRequestDTO}, TContext> => {
    
const mutationKey = ['authControllerAuthenticate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerAuthenticate>>, {data: AuthenticateRequestDTO}> = (props) => {
          const {data} = props ?? {};

          return  authControllerAuthenticate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerAuthenticate>>>
    export type AuthControllerAuthenticateMutationBody = AuthenticateRequestDTO
    export type AuthControllerAuthenticateMutationError = ValidationErrorResponseDto | CommonErrorResponseDto

    /**
 * @summary Authenticate a user
 */
export const useAuthControllerAuthenticate = <TError = ValidationErrorResponseDto | CommonErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerAuthenticate>>, TError,{data: AuthenticateRequestDTO}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof authControllerAuthenticate>>,
        TError,
        {data: AuthenticateRequestDTO},
        TContext
      > => {

      const mutationOptions = getAuthControllerAuthenticateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the current user
 */
export const authControllerMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<MeResponseDto>(
      {url: `http://localhost:3002/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getAuthControllerMeQueryKey = () => {
    return [`http://localhost:3002/auth/me`] as const;
    }

    
export const getAuthControllerMeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof authControllerMe>>>, TError = CommonErrorResponseDto>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeInfiniteQueryError = CommonErrorResponseDto


export function useAuthControllerMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMe>>>, TError = CommonErrorResponseDto>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMe>>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMe>>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current user
 */

export function useAuthControllerMeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof authControllerMe>>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAuthControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerMe>>, TError = CommonErrorResponseDto>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = CommonErrorResponseDto


export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = CommonErrorResponseDto>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authControllerMe>>,
          TError,
          Awaited<ReturnType<typeof authControllerMe>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the current user
 */

export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = CommonErrorResponseDto>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new service
 */
export const servicesControllerCreate = (
    createServiceDto: CreateServiceDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3002/services/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createServiceDto, signal
    },
      );
    }
  


export const getServicesControllerCreateMutationOptions = <TError = CommonResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof servicesControllerCreate>>, TError,{data: CreateServiceDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof servicesControllerCreate>>, TError,{data: CreateServiceDto}, TContext> => {
    
const mutationKey = ['servicesControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof servicesControllerCreate>>, {data: CreateServiceDto}> = (props) => {
          const {data} = props ?? {};

          return  servicesControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ServicesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof servicesControllerCreate>>>
    export type ServicesControllerCreateMutationBody = CreateServiceDto
    export type ServicesControllerCreateMutationError = CommonResponseDto | ValidationErrorResponseDto

    /**
 * @summary Create a new service
 */
export const useServicesControllerCreate = <TError = CommonResponseDto | ValidationErrorResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof servicesControllerCreate>>, TError,{data: CreateServiceDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof servicesControllerCreate>>,
        TError,
        {data: CreateServiceDto},
        TContext
      > => {

      const mutationOptions = getServicesControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all services
 */
export const servicesControllerFindAll = (
    params?: ServicesControllerFindAllParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FindAllServicesResponseDto>(
      {url: `http://localhost:3002/services/list`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getServicesControllerFindAllQueryKey = (params?: ServicesControllerFindAllParams,) => {
    return [`http://localhost:3002/services/list`, ...(params ? [params]: [])] as const;
    }

    
export const getServicesControllerFindAllInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAll>>>, TError = unknown>(params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServicesControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof servicesControllerFindAll>>> = ({ signal }) => servicesControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServicesControllerFindAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof servicesControllerFindAll>>>
export type ServicesControllerFindAllInfiniteQueryError = unknown


export function useServicesControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAll>>>, TError = unknown>(
 params: undefined |  ServicesControllerFindAllParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAll>>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAll>>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all services
 */

export function useServicesControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAll>>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServicesControllerFindAllInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getServicesControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof servicesControllerFindAll>>, TError = unknown>(params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServicesControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof servicesControllerFindAll>>> = ({ signal }) => servicesControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServicesControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof servicesControllerFindAll>>>
export type ServicesControllerFindAllQueryError = unknown


export function useServicesControllerFindAll<TData = Awaited<ReturnType<typeof servicesControllerFindAll>>, TError = unknown>(
 params: undefined |  ServicesControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAll<TData = Awaited<ReturnType<typeof servicesControllerFindAll>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAll<TData = Awaited<ReturnType<typeof servicesControllerFindAll>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all services
 */

export function useServicesControllerFindAll<TData = Awaited<ReturnType<typeof servicesControllerFindAll>>, TError = unknown>(
 params?: ServicesControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServicesControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all availability for a service
 */
export const servicesControllerFindAvailability = (
    serviceId: number,
    params?: ServicesControllerFindAvailabilityParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FindAllAvailabilityServiceResponseDto[]>(
      {url: `http://localhost:3002/services/availability/${serviceId}`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getServicesControllerFindAvailabilityQueryKey = (serviceId: number,
    params?: ServicesControllerFindAvailabilityParams,) => {
    return [`http://localhost:3002/services/availability/${serviceId}`, ...(params ? [params]: [])] as const;
    }

    
export const getServicesControllerFindAvailabilityInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>, TError = unknown>(serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServicesControllerFindAvailabilityQueryKey(serviceId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof servicesControllerFindAvailability>>> = ({ signal }) => servicesControllerFindAvailability(serviceId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServicesControllerFindAvailabilityInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>
export type ServicesControllerFindAvailabilityInfiniteQueryError = unknown


export function useServicesControllerFindAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>, TError = unknown>(
 serviceId: number,
    params: undefined |  ServicesControllerFindAvailabilityParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all availability for a service
 */

export function useServicesControllerFindAvailabilityInfinite<TData = InfiniteData<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServicesControllerFindAvailabilityInfiniteQueryOptions(serviceId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getServicesControllerFindAvailabilityQueryOptions = <TData = Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError = unknown>(serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getServicesControllerFindAvailabilityQueryKey(serviceId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof servicesControllerFindAvailability>>> = ({ signal }) => servicesControllerFindAvailability(serviceId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ServicesControllerFindAvailabilityQueryResult = NonNullable<Awaited<ReturnType<typeof servicesControllerFindAvailability>>>
export type ServicesControllerFindAvailabilityQueryError = unknown


export function useServicesControllerFindAvailability<TData = Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError = unknown>(
 serviceId: number,
    params: undefined |  ServicesControllerFindAvailabilityParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAvailability<TData = Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>,
          TError,
          Awaited<ReturnType<typeof servicesControllerFindAvailability>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useServicesControllerFindAvailability<TData = Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all availability for a service
 */

export function useServicesControllerFindAvailability<TData = Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError = unknown>(
 serviceId: number,
    params?: ServicesControllerFindAvailabilityParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof servicesControllerFindAvailability>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getServicesControllerFindAvailabilityQueryOptions(serviceId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create a new appointment
 */
export const appointmentsControllerCreate = (
    createAppointmentDto: CreateAppointmentDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CommonResponseDto>(
      {url: `http://localhost:3002/appointments/create`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAppointmentDto, signal
    },
      );
    }
  


export const getAppointmentsControllerCreateMutationOptions = <TError = ValidationErrorResponseDto | CommonResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsControllerCreate>>, TError,{data: CreateAppointmentDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appointmentsControllerCreate>>, TError,{data: CreateAppointmentDto}, TContext> => {
    
const mutationKey = ['appointmentsControllerCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appointmentsControllerCreate>>, {data: CreateAppointmentDto}> = (props) => {
          const {data} = props ?? {};

          return  appointmentsControllerCreate(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppointmentsControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof appointmentsControllerCreate>>>
    export type AppointmentsControllerCreateMutationBody = CreateAppointmentDto
    export type AppointmentsControllerCreateMutationError = ValidationErrorResponseDto | CommonResponseDto

    /**
 * @summary Create a new appointment
 */
export const useAppointmentsControllerCreate = <TError = ValidationErrorResponseDto | CommonResponseDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appointmentsControllerCreate>>, TError,{data: CreateAppointmentDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appointmentsControllerCreate>>,
        TError,
        {data: CreateAppointmentDto},
        TContext
      > => {

      const mutationOptions = getAppointmentsControllerCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get all appointments
 */
export const appointmentsControllerFindAll = (
    params?: AppointmentsControllerFindAllParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FindAllAppointmentsResponseDto>(
      {url: `http://localhost:3002/appointments/list`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getAppointmentsControllerFindAllQueryKey = (params?: AppointmentsControllerFindAllParams,) => {
    return [`http://localhost:3002/appointments/list`, ...(params ? [params]: [])] as const;
    }

    
export const getAppointmentsControllerFindAllInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>, TError = CommonResponseDto | void>(params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsControllerFindAll>>> = ({ signal }) => appointmentsControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppointmentsControllerFindAllInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>
export type AppointmentsControllerFindAllInfiniteQueryError = CommonResponseDto | void


export function useAppointmentsControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>, TError = CommonResponseDto | void>(
 params: undefined |  AppointmentsControllerFindAllParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppointmentsControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppointmentsControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all appointments
 */

export function useAppointmentsControllerFindAllInfinite<TData = InfiniteData<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppointmentsControllerFindAllInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getAppointmentsControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError = CommonResponseDto | void>(params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppointmentsControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appointmentsControllerFindAll>>> = ({ signal }) => appointmentsControllerFindAll(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppointmentsControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof appointmentsControllerFindAll>>>
export type AppointmentsControllerFindAllQueryError = CommonResponseDto | void


export function useAppointmentsControllerFindAll<TData = Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError = CommonResponseDto | void>(
 params: undefined |  AppointmentsControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppointmentsControllerFindAll<TData = Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof appointmentsControllerFindAll>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppointmentsControllerFindAll<TData = Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all appointments
 */

export function useAppointmentsControllerFindAll<TData = Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError = CommonResponseDto | void>(
 params?: AppointmentsControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appointmentsControllerFindAll>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppointmentsControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
